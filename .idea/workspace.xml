<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="dca1fd5c-f476-418f-9be5-8200ce8c69c7" name="Changes" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_BRANCH_BY_REPOSITORY">
      <map>
        <entry key="$PROJECT_DIR$" value="master" />
      </map>
    </option>
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 5
}</component>
  <component name="ProjectId" id="2jp0fWy7kGwsVLHZ4PXiNURjwy8" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "Application.Application.executor": "Run",
    "Maven.otus-http-server [clean,package].executor": "Run",
    "Maven.otus-http-server [compile].executor": "Run",
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "kotlin-language-version-configured": "true",
    "last_opened_file_path": "C:/Users/xa86/IdeaProjects/learning-project/otus-http-server/src/main/java/ru/otus/java/basic/processors",
    "node.js.detected.package.eslint": "true",
    "node.js.detected.package.tslint": "true",
    "node.js.selected.package.eslint": "(autodetect)",
    "node.js.selected.package.tslint": "(autodetect)",
    "nodejs_package_manager_path": "npm",
    "project.structure.last.edited": "Project",
    "project.structure.proportion": "0.0",
    "project.structure.side.proportion": "0.0",
    "settings.editor.selected.configurable": "preferences.pluginManager",
    "vue.rearranger.settings.migration": "true"
  }
}]]></component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-http-server\src\main\java\ru\otus\java\basic\processors" />
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-http-server\src\main\java\ru\otus\java\basic\app" />
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-http-server\src\main\java\ru\otus\java\basic" />
    </key>
    <key name="CopyClassDialog.RECENTS_KEY">
      <recent name="ru.otus.java.basic" />
    </key>
  </component>
  <component name="RunManager">
    <configuration name="Application" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.basic.Application" />
      <module name="otus-http-server" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.basic.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Application.Application" />
      </list>
    </recent_temporary>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-jdk-9f38398b9061-18abd8497189-intellij.indexing.shared.core-IU-241.14494.240" />
        <option value="bundled-js-predefined-1d06a55b98c1-74d2a5396914-JavaScript-IU-241.14494.240" />
      </set>
    </attachedChunks>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="dca1fd5c-f476-418f-9be5-8200ce8c69c7" name="Changes" comment="" />
      <created>1722068816109</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1722068816109</updated>
      <workItem from="1722068817273" duration="1415000" />
      <workItem from="1722410982312" duration="7004000" />
      <workItem from="1723364099131" duration="673000" />
    </task>
    <task id="LOCAL-00001" summary="Homework twenty-four basic implementation">
      <option name="closed" value="true" />
      <created>1722412764717</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1722412764717</updated>
    </task>
    <task id="LOCAL-00002" summary="Homework twenty-four v1">
      <option name="closed" value="true" />
      <created>1722424582501</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1722424582501</updated>
    </task>
    <task id="LOCAL-00003" summary="Homework twenty-four v1">
      <option name="closed" value="true" />
      <created>1722424641596</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1722424641596</updated>
    </task>
    <option name="localTasksCounter" value="4" />
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="Homework twenty-four basic implementation" />
    <MESSAGE value="Homework twenty-four v1" />
    <option name="LAST_COMMIT_MESSAGE" value="Homework twenty-four v1" />
  </component>
  <component name="com.github.evgenys91.machinet.common.dslhistory.DslHistoryState">
    <option name="historyDtoById">
      <map>
        <entry key="173e7a">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                </list>
              </option>
              <option name="id" value="173e7a" />
              <option name="initiateTms" value="1722415910029" />
              <option name="request" value=" Этот подход не работает" />
              <option name="response" value="" />
              <option name="responseDescription" value="Понял, давайте пересмотрим подход и убедимся, что все части системы правильно интегрированы и работают вместе. Мы добавим логгирование и проверим, что все компоненты правильно взаимодействуют.&#10;&#10;### Шаг 1: Обновление `ItemsRepository`&#10;&#10;Убедимся, что `ItemsRepository` поддерживает удаление элементов.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class ItemsRepository {&#10;    private Map&lt;Integer, Item&gt; items = new HashMap&lt;&gt;();&#10;    private int currentId = 1;&#10;&#10;    public Item getItem(int id) {&#10;        return items.get(id);&#10;    }&#10;&#10;    public void addItem(Item item) {&#10;        item.setId(currentId++);&#10;        items.put(item.getId(), item);&#10;    }&#10;&#10;    public boolean deleteItem(int id) {&#10;        return items.remove(id) != null;&#10;    }&#10;&#10;    public Map&lt;Integer, Item&gt; getAllItems() {&#10;        return items;&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 2: Создание `DeleteItemProcessor` с логгированием&#10;&#10;Создадим новый класс `DeleteItemProcessor`, который будет обрабатывать запросы на удаление элементов и добавим логгирование.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class DeleteItemProcessor implements RequestProcessor {&#10;    private static final Logger logger = LogManager.getLogger(DeleteItemProcessor.class);&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public DeleteItemProcessor(ItemsRepository itemsRepository) {&#10;        this.itemsRepository = itemsRepository;&#10;    }&#10;&#10;    @Override&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        String idParam = request.getParameter(&quot;id&quot;);&#10;        if (idParam == null) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nMissing 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.warn(&quot;Missing 'id' parameter in request&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            int id = Integer.parseInt(idParam);&#10;            boolean deleted = itemsRepository.deleteItem(id);&#10;            if (deleted) {&#10;                String response = &quot;HTTP/1.1 200 OK\r\n\r\nItem deleted successfully&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.info(&quot;Item with id {} deleted successfully&quot;, id);&#10;            } else {&#10;                String response = &quot;HTTP/1.1 404 Not Found\r\n\r\nItem not found&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.warn(&quot;Item with id {} not found&quot;, id);&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.error(&quot;Invalid 'id' parameter: {}&quot;, idParam, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 3: Регистрация `DeleteItemProcessor` в `Dispatcher`&#10;&#10;Обновим класс `Dispatcher`, чтобы зарегистрировать новый процессор для обработки запросов `DELETE /items`.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Dispatcher {&#10;    private Map&lt;String, RequestProcessor&gt; processors;&#10;    private RequestProcessor defaultNotFoundRequestProcessor;&#10;    private RequestProcessor defaultInternalServerErrorProcessor;&#10;&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public Dispatcher() {&#10;        this.itemsRepository = new ItemsRepository();&#10;&#10;        this.processors = new HashMap&lt;&gt;();&#10;        this.processors.put(&quot;GET /&quot;, new HelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /another&quot;, new AnotherHelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /calculator&quot;, new CalculatorRequestProcessor());&#10;        this.processors.put(&quot;GET /items&quot;, new GetAllItemsProcessor(itemsRepository));&#10;        this.processors.put(&quot;POST /items&quot;, new CreateNewItemProcessor(itemsRepository));&#10;        this.processors.put(&quot;DELETE /items&quot;, new DeleteItemProcessor(itemsRepository)); // Регистрация нового процессора&#10;&#10;        this.defaultNotFoundRequestProcessor = new DefaultNotFoundRequestProcessor();&#10;        this.defaultInternalServerErrorProcessor = new DefaultInternalServerErrorRequestProcessor();&#10;    }&#10;&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        try {&#10;            if (!processors.containsKey(request.getRoutingKey())) {&#10;                defaultNotFoundRequestProcessor.execute(request, out);&#10;                return;&#10;            }&#10;            processors.get(request.getRoutingKey()).execute(request, out);&#10;        } catch (BadRequestException e) {&#10;            e.printStackTrace();&#10;            DefaultErrorDto defaultErrorDto = new DefaultErrorDto(&quot;CLIENT_DEFAULT_ERROR&quot;, e.getMessage());&#10;            String jsonError = new Gson().toJson(defaultErrorDto);&#10;            String response = &quot;&quot; +&#10;                    &quot;HTTP/1.1 400 Bad Request\r\n&quot; +&#10;                    &quot;Content-Type: application/json\r\n&quot; +&#10;                    &quot;\r\n&quot; +&#10;                    jsonError;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            defaultInternalServerErrorProcessor.execute(request, out);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 4: Обновление `HttpRequest` для поддержки параметров&#10;&#10;Убедимся, что `HttpRequest` правильно парсит параметры запроса.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        int startIndex = rawRequest.indexOf(' ');&#10;        int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;        this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;        this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;        &#10;        // Parse parameters from URI&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;\\?&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;&#10;        // Parse headers&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        // Parse body if method is POST&#10;        if (method == HttpMethod.POST) {&#10;            int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;            if (bodyIndex &lt; rawRequest.length()) {&#10;                this.body = rawRequest.substring(bodyIndex);&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo(boolean showRawRequest) {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        if (showRawRequest) {&#10;            logger.info(&quot;rawRequest: {}&quot;, rawRequest);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Итог&#10;&#10;Теперь у вас есть возможность удалять продукты через `DELETE /items?id=10` с логгированием. Мы добавили новый процессор `DeleteItemProcessor`, зарегистрировали его в `Dispatcher`, обновили `ItemsRepository` для поддержки удаления элементов и добавили логгирование для отслеживания процесса удаления. Убедитесь, что все классы находятся в правильных пакетах и импортированы корректно." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722415965951" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="1a58a6">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DeleteItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/ItemsRepository.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/RequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/Item.java" />
                </list>
              </option>
              <option name="id" value="1a58a6" />
              <option name="initiateTms" value="1722415543907" />
              <option name="request" value=" Добавь сюда логгирование" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, давайте добавим логгирование в класс `DeleteItemProcessor`, чтобы отслеживать процесс удаления элементов. Мы будем использовать `LogManager` и `Logger` из библиотеки `log4j`.&#10;&#10;### Обновленный класс `DeleteItemProcessor` с логгированием&#10;&#10;```java&#10;package ru.otus.java.basic.processors;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;import ru.otus.java.basic.HttpRequest;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class DeleteItemProcessor implements RequestProcessor {&#10;    private static final Logger logger = LogManager.getLogger(DeleteItemProcessor.class);&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public DeleteItemProcessor(ItemsRepository itemsRepository) {&#10;        this.itemsRepository = itemsRepository;&#10;    }&#10;&#10;    @Override&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        String idParam = request.getParameter(&quot;id&quot;);&#10;        if (idParam == null) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nMissing 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.warn(&quot;Missing 'id' parameter in request&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            int id = Integer.parseInt(idParam);&#10;            boolean deleted = itemsRepository.deleteItem(id);&#10;            if (deleted) {&#10;                String response = &quot;HTTP/1.1 200 OK\r\n\r\nItem deleted successfully&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.info(&quot;Item with id {} deleted successfully&quot;, id);&#10;            } else {&#10;                String response = &quot;HTTP/1.1 404 Not Found\r\n\r\nItem not found&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.warn(&quot;Item with id {} not found&quot;, id);&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.error(&quot;Invalid 'id' parameter: {}&quot;, idParam, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный класс `Dispatcher` с регистрацией `DeleteItemProcessor`&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import ru.otus.java.basic.processors.*;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Dispatcher {&#10;    private Map&lt;String, RequestProcessor&gt; processors;&#10;    private RequestProcessor defaultNotFoundRequestProcessor;&#10;    private RequestProcessor defaultInternalServerErrorProcessor;&#10;&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public Dispatcher() {&#10;        this.itemsRepository = new ItemsRepository();&#10;&#10;        this.processors = new HashMap&lt;&gt;();&#10;        this.processors.put(&quot;GET /&quot;, new HelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /another&quot;, new AnotherHelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /calculator&quot;, new CalculatorRequestProcessor());&#10;        this.processors.put(&quot;GET /items&quot;, new GetAllItemsProcessor(itemsRepository));&#10;        this.processors.put(&quot;POST /items&quot;, new CreateNewItemProcessor(itemsRepository));&#10;        this.processors.put(&quot;DELETE /items&quot;, new DeleteItemProcessor(itemsRepository)); // Регистрация нового процессора&#10;&#10;        this.defaultNotFoundRequestProcessor = new DefaultNotFoundRequestProcessor();&#10;        this.defaultInternalServerErrorProcessor = new DefaultInternalServerErrorRequestProcessor();&#10;    }&#10;&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        try {&#10;            if (!processors.containsKey(request.getRoutingKey())) {&#10;                defaultNotFoundRequestProcessor.execute(request, out);&#10;                return;&#10;            }&#10;            processors.get(request.getRoutingKey()).execute(request, out);&#10;        } catch (BadRequestException e) {&#10;            e.printStackTrace();&#10;            DefaultErrorDto defaultErrorDto = new DefaultErrorDto(&quot;CLIENT_DEFAULT_ERROR&quot;, e.getMessage());&#10;            String jsonError = new Gson().toJson(defaultErrorDto);&#10;            String response = &quot;&quot; +&#10;                    &quot;HTTP/1.1 400 Bad Request\r\n&quot; +&#10;                    &quot;Content-Type: application/json\r\n&quot; +&#10;                    &quot;\r\n&quot; +&#10;                    jsonError;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            defaultInternalServerErrorProcessor.execute(request, out);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный класс `ItemsRepository` для поддержки удаления элементов&#10;&#10;```java&#10;package ru.otus.java.basic.app;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;public class ItemsRepository {&#10;    private List&lt;Item&gt; items;&#10;&#10;    public List&lt;Item&gt; getItems() {&#10;        return Collections.unmodifiableList(items);&#10;    }&#10;&#10;    public ItemsRepository() {&#10;        this.items = new ArrayList&lt;&gt;(Arrays.asList(&#10;                new Item(1L, &quot;Milk&quot;, BigDecimal.valueOf(80)),&#10;                new Item(2L, &quot;Bread&quot;, BigDecimal.valueOf(32)),&#10;                new Item(3L, &quot;Cheese&quot;, BigDecimal.valueOf(320))&#10;        ));&#10;    }&#10;&#10;    public Item add(Item item) {&#10;        Long newId = items.stream().mapToLong(Item::getId).max().orElse(0L) + 1L;&#10;        item.setId(newId);&#10;        items.add(item);&#10;        return item;&#10;    }&#10;&#10;    public boolean deleteItem(int id) {&#10;        return items.removeIf(item -&gt; item.getId() == id);&#10;    }&#10;}&#10;```&#10;&#10;### Итог&#10;&#10;Теперь у вас есть возможность удалять продукты через `DELETE /items?id=10` с логгированием. Мы добавили новый процессор `DeleteItemProcessor`, зарегистрировали его в `Dispatcher`, обновили `ItemsRepository` для поддержки удаления элементов и добавили логгирование для отслеживания процесса удаления." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722415565895" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/Item.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/RequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DeleteItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/ItemsRepository.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="30bc76">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
              <option name="id" value="30bc76" />
              <option name="initiateTms" value="1722414677267" />
              <option name="response" value="" />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722414709175" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="349ace">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
              <option name="id" value="349ace" />
              <option name="initiateTms" value="1722414876630" />
              <option name="request" value=" Вот изначальный класс&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private String body;&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parse();&#10;    }&#10;&#10;    private void parse() {&#10;        int startIndex = rawRequest.indexOf(' ');&#10;        int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;        this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;        this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;[?]&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;        if (method == HttpMethod.POST) {&#10;            this.body = rawRequest.substring(&#10;                    rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4&#10;            );&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo(boolean showRawRequest) {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        if (showRawRequest) {&#10;            logger.info(&quot;rawRequest: {}&quot;, rawRequest);&#10;        }&#10;    }&#10;}" />
              <option name="response" value="" />
              <option name="responseDescription" value="Понял, давайте обновим ваш класс `HttpRequest`, чтобы включить парсинг заголовков запроса в `Map&lt;String, String&gt;`. Мы добавим новое поле для хранения заголовков и обновим метод `parse`, чтобы он извлекал заголовки из сырого HTTP-запроса.&#10;&#10;### Обновленный класс `HttpRequest`&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        String[] requestLine = lines[0].split(&quot; &quot;);&#10;        this.method = HttpMethod.valueOf(requestLine[0]);&#10;        this.uri = requestLine[1];&#10;&#10;        // Parse parameters from URI&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;\\?&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;&#10;        // Parse headers&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        // Parse body if method is POST&#10;        if (method == HttpMethod.POST) {&#10;            int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;            if (bodyIndex &lt; rawRequest.length()) {&#10;                this.body = rawRequest.substring(bodyIndex);&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo(boolean showRawRequest) {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        if (showRawRequest) {&#10;            logger.info(&quot;rawRequest: {}&quot;, rawRequest);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений&#10;&#10;1. **Новое поле `headers`:** Добавлено поле `headers` типа `Map&lt;String, String&gt;` для хранения заголовков запроса.&#10;2. **Инициализация `headers`:** В конструкторе инициализируется новое поле `headers`.&#10;3. **Парсинг заголовков:** В методе `parse` добавлен цикл для парсинга заголовков из строк запроса.&#10;4. **Метод `getHeaders`:** Добавлен метод `getHeaders` для получения заголовков.&#10;&#10;Теперь ваш класс `HttpRequest` будет парсить заголовки HTTP-запроса и сохранять их в `Map&lt;String, String&gt;`, что позволит вам легко получать доступ к заголовкам запроса." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722414922292" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="40f023">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                </list>
              </option>
              <option name="id" value="40f023" />
              <option name="initiateTms" value="1722415001859" />
              <option name="request" value=" Не меняй предыдущую логику, добавь только парсинг заголовков запроса в Map&lt;String, String&gt;" />
              <option name="response" value="" />
              <option name="responseDescription" value="Понял, давайте добавим парсинг заголовков запроса в `Map&lt;String, String&gt;`, не изменяя существующую логику.&#10;&#10;### Обновленный класс `HttpRequest`&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        int startIndex = rawRequest.indexOf(' ');&#10;        int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;        this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;        this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;        &#10;        // Parse parameters from URI&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;\\?&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;&#10;        // Parse headers&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        // Parse body if method is POST&#10;        if (method == HttpMethod.POST) {&#10;            int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;            if (bodyIndex &lt; rawRequest.length()) {&#10;                this.body = rawRequest.substring(bodyIndex);&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo(boolean showRawRequest) {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        if (showRawRequest) {&#10;            logger.info(&quot;rawRequest: {}&quot;, rawRequest);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений&#10;&#10;1. **Новое поле `headers`:** Добавлено поле `headers` типа `Map&lt;String, String&gt;` для хранения заголовков запроса.&#10;2. **Инициализация `headers`:** В конструкторе инициализируется новое поле `headers`.&#10;3. **Парсинг заголовков:** В методе `parse` добавлен цикл для парсинга заголовков из строк запроса, начиная со второй строки (индекс 1) до первой пустой строки.&#10;&#10;Теперь ваш класс `HttpRequest` будет парсить заголовки HTTP-запроса и сохранять их в `Map&lt;String, String&gt;`, не изменяя существующую логику." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722415012067" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="7e3935">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/ItemsRepository.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/AnotherHelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CalculatorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CreateNewItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultInternalServerErrorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultNotFoundRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/GetAllItemsProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/HelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/RequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/DefaultErrorDto.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/BadRequestException.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
              <option name="id" value="7e3935" />
              <option name="initiateTms" value="1722415172170" />
              <option name="request" value=" Что значит rawRequest" />
              <option name="response" value="" />
              <option name="responseDescription" value="`rawRequest` — это строка, представляющая собой полный сырой HTTP-запрос, полученный от клиента. Этот запрос включает в себя все части HTTP-запроса, такие как стартовая строка (метод, URI, версия протокола), заголовки и тело запроса (если оно есть).&#10;&#10;Пример сырого HTTP-запроса (`rawRequest`):&#10;&#10;```&#10;POST /items HTTP/1.1&#10;Host: example.com&#10;Content-Type: application/json&#10;Content-Length: 27&#10;&#10;{&quot;name&quot;:&quot;Milk&quot;,&quot;price&quot;:80}&#10;```&#10;&#10;В этом примере `rawRequest` включает:&#10;&#10;1. **Стартовая строка:** `POST /items HTTP/1.1`&#10;2. **Заголовки:** &#10;   ```&#10;   Host: example.com&#10;   Content-Type: application/json&#10;   Content-Length: 27&#10;   ```&#10;3. **Пустая строка:** Разделяет заголовки и тело запроса.&#10;4. **Тело запроса:** `{&quot;name&quot;:&quot;Milk&quot;,&quot;price&quot;:80}`&#10;&#10;### Обновленный класс `HttpRequest` с комментариями&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest; // Сырой HTTP-запрос&#10;    private String uri; // URI запроса&#10;    private HttpMethod method; // HTTP-метод (GET, POST и т.д.)&#10;    private Map&lt;String, String&gt; parameters; // Параметры запроса&#10;    private Map&lt;String, String&gt; headers; // Заголовки запроса&#10;    private String body; // Тело запроса&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        // Парсинг стартовой строки&#10;        int startIndex = rawRequest.indexOf(' ');&#10;        int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;        this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;        this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;        &#10;        // Парсинг параметров из URI&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;\\?&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;&#10;        // Парсинг заголовков&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        // Парсинг тела запроса, если метод POST&#10;        if (method == HttpMethod.POST) {&#10;            int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;            if (bodyIndex &lt; rawRequest.length()) {&#10;                this.body = rawRequest.substring(bodyIndex);&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo(boolean showRawRequest) {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        if (showRawRequest) {&#10;            logger.info(&quot;rawRequest: {}&quot;, rawRequest);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений&#10;&#10;1. **Поле `rawRequest`:** Хранит полный сырой HTTP-запрос в виде строки.&#10;2. **Метод `parse`:** Парсит `rawRequest` для извлечения метода, URI, параметров, заголовков и тела запроса.&#10;3. **Метод `getHeaders`:** Возвращает заголовки запроса в виде `Map&lt;String, String&gt;`.&#10;&#10;Теперь ваш класс `HttpRequest` будет парсить заголовки HTTP-запроса и сохранять их в `Map&lt;String, String&gt;`, не изменяя существующую логику." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722415199584" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/GetAllItemsProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CalculatorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/DefaultErrorDto.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultNotFoundRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultInternalServerErrorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/HelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/RequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/BadRequestException.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CreateNewItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/AnotherHelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/ItemsRepository.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="8363be">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
              <option name="id" value="8363be" />
              <option name="initiateTms" value="1723364412536" />
              <option name="request" value=" В классе HttpRequest над строчкой String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;получил комментарий &#10;Лучше сделать String[] header = lines[i].split(&quot;: &quot;, 2); чтобы защититься от : в вельюс и от следующего ифа избавиться" />
              <option name="response" value="" />
              <option name="responseDescription" value="Да, это хороший совет. Использование метода `split` с ограничением на количество частей (`split(&quot;: &quot;, 2)`) позволяет избежать проблем, связанных с наличием символа `:` в значениях заголовков. Это также позволяет избавиться от дополнительной проверки длины массива.&#10;&#10;Давайте обновим ваш класс `HttpRequest` с учетом этого совета и добавим дополнительные улучшения для обработки ошибок и логгирования.&#10;&#10;### Обновленный класс `HttpRequest`&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        try {&#10;            int startIndex = rawRequest.indexOf(' ');&#10;            int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;            this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;            this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;&#10;            // Parse parameters from URI&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] elements = uri.split(&quot;\\?&quot;);&#10;                this.uri = elements[0];&#10;                String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;                for (String o : keysValues) {&#10;                    String[] keyValue = o.split(&quot;=&quot;);&#10;                    if (keyValue.length == 2) {&#10;                        this.parameters.put(keyValue[0], keyValue[1]);&#10;                    } else {&#10;                        logger.warn(&quot;Invalid parameter format: {}&quot;, o);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Parse headers&#10;            String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;            int i = 1;&#10;            while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;, 2);&#10;                headers.put(header[0], header[1]);&#10;                i++;&#10;            }&#10;&#10;            // Parse body if method is POST&#10;            if (method == HttpMethod.POST) {&#10;                int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;                if (bodyIndex &lt; rawRequest.length()) {&#10;                    this.body = rawRequest.substring(bodyIndex);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing HTTP request: {}&quot;, rawRequest, e);&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo() {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        logger.info(&quot;parameters: {}&quot;, parameters);&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный `DeleteItemProcessor` с дополнительным логгированием&#10;&#10;```java&#10;package ru.otus.java.basic.processors;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;import ru.otus.java.basic.HttpRequest;&#10;import ru.otus.java.basic.RequestProcessor;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class DeleteItemProcessor implements RequestProcessor {&#10;    private static final Logger logger = LogManager.getLogger(DeleteItemProcessor.class);&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public DeleteItemProcessor(ItemsRepository itemsRepository) {&#10;        this.itemsRepository = itemsRepository;&#10;    }&#10;&#10;    @Override&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        logger.info(&quot;Processing DELETE request for URI: {}&quot;, request.getUri());&#10;        String idParam = request.getParameter(&quot;id&quot;);&#10;        if (idParam == null) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nMissing 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.warn(&quot;Missing 'id' parameter in request&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            int id = Integer.parseInt(idParam);&#10;            boolean deleted = itemsRepository.deleteItem(id);&#10;            if (deleted) {&#10;                String response = &quot;HTTP/1.1 200 OK\r\n\r\nItem deleted successfully&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.info(&quot;Item with id {} deleted successfully&quot;, id);&#10;            } else {&#10;                String response = &quot;HTTP/1.1 404 Not Found\r\n\r\nItem not found&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.warn(&quot;Item with id {} not found&quot;, id);&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.error(&quot;Invalid 'id' parameter: {}&quot;, idParam, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный `Dispatcher` с дополнительным логгированием&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import com.google.gson.Gson;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;import ru.otus.java.basic.processors.*;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Dispatcher {&#10;    private static final Logger logger = LogManager.getLogger(Dispatcher.class);&#10;    private Map&lt;String, RequestProcessor&gt; processors;&#10;    private RequestProcessor defaultNotFoundRequestProcessor;&#10;    private RequestProcessor defaultInternalServerErrorProcessor;&#10;&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public Dispatcher() {&#10;        this.itemsRepository = new ItemsRepository();&#10;&#10;        this.processors = new HashMap&lt;&gt;();&#10;        this.processors.put(&quot;GET /&quot;, new HelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /another&quot;, new AnotherHelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /calculator&quot;, new CalculatorRequestProcessor());&#10;        this.processors.put(&quot;GET /items&quot;, new GetAllItemsProcessor(itemsRepository));&#10;        this.processors.put(&quot;POST /items&quot;, new CreateNewItemProcessor(itemsRepository));&#10;        this.processors.put(&quot;DELETE /items&quot;, new DeleteItemProcessor(itemsRepository)); // Регистрация нового процессора&#10;&#10;        this.defaultNotFoundRequestProcessor = new DefaultNotFoundRequestProcessor();&#10;        this.defaultInternalServerErrorProcessor = new DefaultInternalServerErrorRequestProcessor();&#10;    }&#10;&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        try {&#10;            logger.info(&quot;Received request: {}&quot;, request.getRoutingKey());&#10;            if (!processors.containsKey(request.getRoutingKey())) {&#10;                logger.warn(&quot;No processor found for request: {}&quot;, request.getRoutingKey());&#10;                defaultNotFoundRequestProcessor.execute(request, out);&#10;                return;&#10;            }&#10;            processors.get(request.getRoutingKey()).execute(request, out);&#10;        } catch (BadRequestException e) {&#10;            logger.error(&quot;Bad request: {}&quot;, e.getMessage(), e);&#10;            DefaultErrorDto defaultErrorDto = new DefaultErrorDto(&quot;CLIENT_DEFAULT_ERROR&quot;, e.getMessage());&#10;            String jsonError = new Gson().toJson(defaultErrorDto);&#10;            String response = &quot;&quot; +&#10;                    &quot;HTTP/1.1 400 Bad Request\r\n&quot; +&#10;                    &quot;Content-Type: application/json\r\n&quot; +&#10;                    &quot;\r\n&quot; +&#10;                    jsonError;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Internal server error: {}&quot;, e.getMessage(), e);&#10;            defaultInternalServerErrorProcessor.execute(request, out);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Итог&#10;&#10;Теперь ваш класс `HttpRequest` использует метод `split(&quot;: &quot;, 2)` для корректного парсинга заголовков, что позволяет избежать проблем с наличием символа `:` в значениях заголовков. Мы также добавили дополнительное логгирование для лучшей диагностики и обработки ошибок. Эти изменения должны помочь вам лучше понять, что происходит в системе и почему может возникать ошибка &quot;socket hang up&quot;." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1723364455202" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="8a0254">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                </list>
              </option>
              <option name="id" value="8a0254" />
              <option name="initiateTms" value="1722414598299" />
              <option name="request" value=" Сделайте парсинг заголовков запроса в Map&lt;String, String&gt;" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для выполнения парсинга заголовков запроса в `Map&lt;String, String&gt;`, нам нужно будет обновить класс `HttpRequest` для включения этой функциональности. Предполагая, что у вас уже есть класс `HttpRequest`, мы добавим метод для парсинга заголовков.&#10;&#10;### Обновление класса `HttpRequest`&#10;&#10;1. Добавим поле для хранения заголовков.&#10;2. Добавим метод для парсинга заголовков из сырого HTTP-запроса.&#10;&#10;### Пример реализации&#10;&#10;```java&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private String method;&#10;    private String path;&#10;    private String version;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.headers = new HashMap&lt;&gt;();&#10;        parseRequest(rawRequest);&#10;    }&#10;&#10;    private void parseRequest(String rawRequest) {&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        String[] requestLine = lines[0].split(&quot; &quot;);&#10;        this.method = requestLine[0];&#10;        this.path = requestLine[1];&#10;        this.version = requestLine[2];&#10;&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        // Assuming the body starts after an empty line&#10;        if (i &lt; lines.length &amp;&amp; lines[i].isEmpty()) {&#10;            StringBuilder bodyBuilder = new StringBuilder();&#10;            for (int j = i + 1; j &lt; lines.length; j++) {&#10;                bodyBuilder.append(lines[j]).append(&quot;\r\n&quot;);&#10;            }&#10;            this.body = bodyBuilder.toString().trim();&#10;        }&#10;    }&#10;&#10;    public String getMethod() {&#10;        return method;&#10;    }&#10;&#10;    public String getPath() {&#10;        return path;&#10;    }&#10;&#10;    public String getVersion() {&#10;        return version;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + path;&#10;    }&#10;&#10;    public void printInfo(boolean printHeaders) {&#10;        System.out.println(&quot;Method: &quot; + method);&#10;        System.out.println(&quot;Path: &quot; + path);&#10;        System.out.println(&quot;Version: &quot; + version);&#10;        if (printHeaders) {&#10;            System.out.println(&quot;Headers: &quot; + headers);&#10;        }&#10;        System.out.println(&quot;Body: &quot; + body);&#10;    }&#10;}&#10;```&#10;&#10;### Обновление класса `RequestHandler`&#10;&#10;Теперь, когда у нас есть парсинг заголовков в классе `HttpRequest`, мы можем обновить `RequestHandler`, чтобы использовать этот новый функционал.&#10;&#10;```java&#10;public class RequestHandler implements Runnable {&#10;    private Socket socket;&#10;    private Dispatcher dispatcher;&#10;&#10;    public RequestHandler(Socket socket, Dispatcher dispatcher) {&#10;        this.socket = socket;&#10;        this.dispatcher = dispatcher;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            byte[] buffer = new byte[8192];&#10;            int n = socket.getInputStream().read(buffer);&#10;            String rawRequest = new String(buffer, 0, n);&#10;            HttpRequest request = new HttpRequest(rawRequest);&#10;            request.printInfo(true);&#10;            dispatcher.execute(request, socket.getOutputStream());&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        } finally {&#10;            try {&#10;                socket.close();&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;Теперь заголовки HTTP-запроса будут парситься и сохраняться в `Map&lt;String, String&gt;` в классе `HttpRequest`. Вы можете получить доступ к заголовкам через метод `getHeaders()`." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722414616905" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="a76bb9">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
              <option name="id" value="a76bb9" />
              <option name="initiateTms" value="1722416253219" />
              <option name="request" value=" Вот класс парсинга:&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parse();&#10;    }&#10;&#10;    private void parse() {&#10;        int startIndex = rawRequest.indexOf(' ');&#10;        int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;        this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;        this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;[?]&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        if (method == HttpMethod.POST) {&#10;            this.body = rawRequest.substring(&#10;                    rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4&#10;            );&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo() {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;    }&#10;}&#10;&#10;Может в нем нужно что-то поменять или добавить?" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ваш класс `HttpRequest` выглядит в целом правильно, но давайте добавим несколько улучшений и проверок, чтобы убедиться, что он корректно обрабатывает все возможные случаи. Мы также добавим дополнительное логгирование для диагностики.&#10;&#10;### Обновленный класс `HttpRequest`&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        try {&#10;            int startIndex = rawRequest.indexOf(' ');&#10;            int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;            this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;            this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;&#10;            // Parse parameters from URI&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] elements = uri.split(&quot;\\?&quot;);&#10;                this.uri = elements[0];&#10;                String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;                for (String o : keysValues) {&#10;                    String[] keyValue = o.split(&quot;=&quot;);&#10;                    if (keyValue.length == 2) {&#10;                        this.parameters.put(keyValue[0], keyValue[1]);&#10;                    } else {&#10;                        logger.warn(&quot;Invalid parameter format: {}&quot;, o);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Parse headers&#10;            String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;            int i = 1;&#10;            while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                if (header.length == 2) {&#10;                    headers.put(header[0], header[1]);&#10;                } else {&#10;                    logger.warn(&quot;Invalid header format: {}&quot;, lines[i]);&#10;                }&#10;                i++;&#10;            }&#10;&#10;            // Parse body if method is POST&#10;            if (method == HttpMethod.POST) {&#10;                int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;                if (bodyIndex &lt; rawRequest.length()) {&#10;                    this.body = rawRequest.substring(bodyIndex);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing HTTP request: {}&quot;, rawRequest, e);&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo() {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        logger.info(&quot;parameters: {}&quot;, parameters);&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный `DeleteItemProcessor` с дополнительным логгированием&#10;&#10;```java&#10;package ru.otus.java.basic.processors;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;import ru.otus.java.basic.HttpRequest;&#10;import ru.otus.java.basic.RequestProcessor;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class DeleteItemProcessor implements RequestProcessor {&#10;    private static final Logger logger = LogManager.getLogger(DeleteItemProcessor.class);&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public DeleteItemProcessor(ItemsRepository itemsRepository) {&#10;        this.itemsRepository = itemsRepository;&#10;    }&#10;&#10;    @Override&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        logger.info(&quot;Processing DELETE request for URI: {}&quot;, request.getUri());&#10;        String idParam = request.getParameter(&quot;id&quot;);&#10;        if (idParam == null) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nMissing 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.warn(&quot;Missing 'id' parameter in request&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            int id = Integer.parseInt(idParam);&#10;            boolean deleted = itemsRepository.deleteItem(id);&#10;            if (deleted) {&#10;                String response = &quot;HTTP/1.1 200 OK\r\n\r\nItem deleted successfully&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.info(&quot;Item with id {} deleted successfully&quot;, id);&#10;            } else {&#10;                String response = &quot;HTTP/1.1 404 Not Found\r\n\r\nItem not found&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.warn(&quot;Item with id {} not found&quot;, id);&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.error(&quot;Invalid 'id' parameter: {}&quot;, idParam, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный `Dispatcher` с дополнительным логгированием&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import com.google.gson.Gson;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;import ru.otus.java.basic.processors.*;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Dispatcher {&#10;    private static final Logger logger = LogManager.getLogger(Dispatcher.class);&#10;    private Map&lt;String, RequestProcessor&gt; processors;&#10;    private RequestProcessor defaultNotFoundRequestProcessor;&#10;    private RequestProcessor defaultInternalServerErrorProcessor;&#10;&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public Dispatcher() {&#10;        this.itemsRepository = new ItemsRepository();&#10;&#10;        this.processors = new HashMap&lt;&gt;();&#10;        this.processors.put(&quot;GET /&quot;, new HelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /another&quot;, new AnotherHelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /calculator&quot;, new CalculatorRequestProcessor());&#10;        this.processors.put(&quot;GET /items&quot;, new GetAllItemsProcessor(itemsRepository));&#10;        this.processors.put(&quot;POST /items&quot;, new CreateNewItemProcessor(itemsRepository));&#10;        this.processors.put(&quot;DELETE /items&quot;, new DeleteItemProcessor(itemsRepository)); // Регистрация нового процессора&#10;&#10;        this.defaultNotFoundRequestProcessor = new DefaultNotFoundRequestProcessor();&#10;        this.defaultInternalServerErrorProcessor = new DefaultInternalServerErrorRequestProcessor();&#10;    }&#10;&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        try {&#10;            logger.info(&quot;Received request: {}&quot;, request.getRoutingKey());&#10;            if (!processors.containsKey(request.getRoutingKey())) {&#10;                logger.warn(&quot;No processor found for request: {}&quot;, request.getRoutingKey());&#10;                defaultNotFoundRequestProcessor.execute(request, out);&#10;                return;&#10;            }&#10;            processors.get(request.getRoutingKey()).execute(request, out);&#10;        } catch (BadRequestException e) {&#10;            logger.error(&quot;Bad request: {}&quot;, e.getMessage(), e);&#10;            DefaultErrorDto defaultErrorDto = new DefaultErrorDto(&quot;CLIENT_DEFAULT_ERROR&quot;, e.getMessage());&#10;            String jsonError = new Gson().toJson(defaultErrorDto);&#10;            String response = &quot;&quot; +&#10;                    &quot;HTTP/1.1 400 Bad Request\r\n&quot; +&#10;                    &quot;Content-Type: application/json\r\n&quot; +&#10;                    &quot;\r\n&quot; +&#10;                    jsonError;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Internal server error: {}&quot;, e.getMessage(), e);&#10;            defaultInternalServerErrorProcessor.execute(request, out);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Итог&#10;&#10;Теперь у вас есть обновленный класс `HttpRequest`, который включает дополнительные проверки и логгирование. Мы также добавили дополнительное логгирование в `DeleteItemProcessor` и `Dispatcher` для лучшей диагностики. Эти изменения должны помочь вам лучше понять, что происходит в системе и почему может возникать ошибка &quot;socket hang up&quot;." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722416277196" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="b4733e">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/ItemsRepository.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/AnotherHelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CalculatorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CreateNewItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultInternalServerErrorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultNotFoundRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DeleteItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/GetAllItemsProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/HelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/RequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/DefaultErrorDto.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/BadRequestException.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/Item.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                </list>
              </option>
              <option name="id" value="b4733e" />
              <option name="initiateTms" value="1722416098404" />
              <option name="request" value=" Error: socket hang up" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибка &quot;socket hang up&quot; обычно указывает на то, что соединение было неожиданно закрыто. Это может произойти по нескольким причинам, включая проблемы с сервером, неправильную обработку запросов или ошибки в коде.&#10;&#10;Давайте убедимся, что все части системы правильно настроены и работают вместе. Мы также добавим дополнительные логгирования для диагностики проблемы.&#10;&#10;### Шаг 1: Убедитесь, что `ItemsRepository` правильно настроен&#10;&#10;```java&#10;package ru.otus.java.basic.app;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;public class ItemsRepository {&#10;    private List&lt;Item&gt; items;&#10;&#10;    public List&lt;Item&gt; getItems() {&#10;        return Collections.unmodifiableList(items);&#10;    }&#10;&#10;    public ItemsRepository() {&#10;        this.items = new ArrayList&lt;&gt;(Arrays.asList(&#10;                new Item(1L, &quot;Milk&quot;, BigDecimal.valueOf(80)),&#10;                new Item(2L, &quot;Bread&quot;, BigDecimal.valueOf(32)),&#10;                new Item(3L, &quot;Cheese&quot;, BigDecimal.valueOf(320))&#10;        ));&#10;    }&#10;&#10;    public Item add(Item item) {&#10;        Long newId = items.stream().mapToLong(Item::getId).max().orElse(0L) + 1L;&#10;        item.setId(newId);&#10;        items.add(item);&#10;        return item;&#10;    }&#10;&#10;    public boolean deleteItem(int id) {&#10;        return items.removeIf(item -&gt; item.getId() == id);&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 2: Обновите `DeleteItemProcessor` с логгированием&#10;&#10;```java&#10;package ru.otus.java.basic.processors;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;import ru.otus.java.basic.HttpRequest;&#10;import ru.otus.java.basic.RequestProcessor;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class DeleteItemProcessor implements RequestProcessor {&#10;    private static final Logger logger = LogManager.getLogger(DeleteItemProcessor.class);&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public DeleteItemProcessor(ItemsRepository itemsRepository) {&#10;        this.itemsRepository = itemsRepository;&#10;    }&#10;&#10;    @Override&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        String idParam = request.getParameter(&quot;id&quot;);&#10;        if (idParam == null) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nMissing 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.warn(&quot;Missing 'id' parameter in request&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            int id = Integer.parseInt(idParam);&#10;            boolean deleted = itemsRepository.deleteItem(id);&#10;            if (deleted) {&#10;                String response = &quot;HTTP/1.1 200 OK\r\n\r\nItem deleted successfully&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.info(&quot;Item with id {} deleted successfully&quot;, id);&#10;            } else {&#10;                String response = &quot;HTTP/1.1 404 Not Found\r\n\r\nItem not found&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;                logger.warn(&quot;Item with id {} not found&quot;, id);&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            logger.error(&quot;Invalid 'id' parameter: {}&quot;, idParam, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 3: Обновите `Dispatcher` для регистрации `DeleteItemProcessor`&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import com.google.gson.Gson;&#10;import ru.otus.java.basic.app.ItemsRepository;&#10;import ru.otus.java.basic.processors.*;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Dispatcher {&#10;    private Map&lt;String, RequestProcessor&gt; processors;&#10;    private RequestProcessor defaultNotFoundRequestProcessor;&#10;    private RequestProcessor defaultInternalServerErrorProcessor;&#10;&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public Dispatcher() {&#10;        this.itemsRepository = new ItemsRepository();&#10;&#10;        this.processors = new HashMap&lt;&gt;();&#10;        this.processors.put(&quot;GET /&quot;, new HelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /another&quot;, new AnotherHelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /calculator&quot;, new CalculatorRequestProcessor());&#10;        this.processors.put(&quot;GET /items&quot;, new GetAllItemsProcessor(itemsRepository));&#10;        this.processors.put(&quot;POST /items&quot;, new CreateNewItemProcessor(itemsRepository));&#10;        this.processors.put(&quot;DELETE /items&quot;, new DeleteItemProcessor(itemsRepository)); // Регистрация нового процессора&#10;&#10;        this.defaultNotFoundRequestProcessor = new DefaultNotFoundRequestProcessor();&#10;        this.defaultInternalServerErrorProcessor = new DefaultInternalServerErrorRequestProcessor();&#10;    }&#10;&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        try {&#10;            if (!processors.containsKey(request.getRoutingKey())) {&#10;                defaultNotFoundRequestProcessor.execute(request, out);&#10;                return;&#10;            }&#10;            processors.get(request.getRoutingKey()).execute(request, out);&#10;        } catch (BadRequestException e) {&#10;            e.printStackTrace();&#10;            DefaultErrorDto defaultErrorDto = new DefaultErrorDto(&quot;CLIENT_DEFAULT_ERROR&quot;, e.getMessage());&#10;            String jsonError = new Gson().toJson(defaultErrorDto);&#10;            String response = &quot;&quot; +&#10;                    &quot;HTTP/1.1 400 Bad Request\r\n&quot; +&#10;                    &quot;Content-Type: application/json\r\n&quot; +&#10;                    &quot;\r\n&quot; +&#10;                    jsonError;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            defaultInternalServerErrorProcessor.execute(request, out);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 4: Убедитесь, что `HttpRequest` правильно парсит параметры&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private static final Logger logger = LogManager.getLogger(HttpRequest.class);&#10;&#10;    private String rawRequest;&#10;    private String uri;&#10;    private HttpMethod method;&#10;    private Map&lt;String, String&gt; parameters;&#10;    private Map&lt;String, String&gt; headers;&#10;    private String body;&#10;&#10;    public HttpRequest(String rawRequest) {&#10;        this.rawRequest = rawRequest;&#10;        this.parameters = new HashMap&lt;&gt;();&#10;        this.headers = new HashMap&lt;&gt;();&#10;        this.parse();&#10;    }&#10;&#10;    public String getRoutingKey() {&#10;        return method + &quot; &quot; + uri;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public String getBody() {&#10;        return body;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    private void parse() {&#10;        int startIndex = rawRequest.indexOf(' ');&#10;        int endIndex = rawRequest.indexOf(' ', startIndex + 1);&#10;        this.uri = rawRequest.substring(startIndex + 1, endIndex);&#10;        this.method = HttpMethod.valueOf(rawRequest.substring(0, startIndex));&#10;        &#10;        // Parse parameters from URI&#10;        if (uri.contains(&quot;?&quot;)) {&#10;            String[] elements = uri.split(&quot;\\?&quot;);&#10;            this.uri = elements[0];&#10;            String[] keysValues = elements[1].split(&quot;&amp;&quot;);&#10;            for (String o : keysValues) {&#10;                String[] keyValue = o.split(&quot;=&quot;);&#10;                this.parameters.put(keyValue[0], keyValue[1]);&#10;            }&#10;        }&#10;&#10;        // Parse headers&#10;        String[] lines = rawRequest.split(&quot;\r\n&quot;);&#10;        int i = 1;&#10;        while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;            String[] header = lines[i].split(&quot;: &quot;);&#10;            if (header.length == 2) {&#10;                headers.put(header[0], header[1]);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        // Parse body if method is POST&#10;        if (method == HttpMethod.POST) {&#10;            int bodyIndex = rawRequest.indexOf(&quot;\r\n\r\n&quot;) + 4;&#10;            if (bodyIndex &lt; rawRequest.length()) {&#10;                this.body = rawRequest.substring(bodyIndex);&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean containsParameter(String key) {&#10;        return parameters.containsKey(key);&#10;    }&#10;&#10;    public String getParameter(String key) {&#10;        return parameters.get(key);&#10;    }&#10;&#10;    public void printInfo(boolean showRawRequest) {&#10;        logger.info(&quot;uri: {}&quot;, uri);&#10;        logger.info(&quot;method: {}&quot;, method);&#10;        logger.info(&quot;body: {}&quot;, body);&#10;        logger.info(&quot;headers: {}&quot;, headers);&#10;        if (showRawRequest) {&#10;            logger.info(&quot;rawRequest: {}&quot;, rawRequest);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Итог&#10;&#10;Теперь у вас есть возможность удалять продукты через `DELETE /items?id=10` с логгированием. Мы добавили новый процессор `DeleteItemProcessor`, зарегистрировали его в `Dispatcher`, обновили `ItemsRepository` для поддержки удаления элементов и добавили логгирование для отслеживания процесса удаления. Убедитесь, что все классы находятся в правильных пакетах и импортированы корректно." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722416144431" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/GetAllItemsProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CalculatorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/DefaultErrorDto.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/Item.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultNotFoundRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/HelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DefaultInternalServerErrorRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpRequest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/RequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpMethod.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/DeleteItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/BadRequestException.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/CreateNewItemProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/processors/AnotherHelloWorldRequestProcessor.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/app/ItemsRepository.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="fddd84">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                </list>
              </option>
              <option name="id" value="fddd84" />
              <option name="initiateTms" value="1722415305339" />
              <option name="request" value=" - * Добавьте возможность удалять продукты через DELETE /items?id=10 (т.е. сервер должен удалить продукт с ид=10)" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для добавления возможности удалять продукты через `DELETE /items?id=10`, нам нужно внести изменения в несколько классов:&#10;&#10;1. Добавить новый процессор для обработки запросов `DELETE /items`.&#10;2. Зарегистрировать этот процессор в `Dispatcher`.&#10;3. Обновить репозиторий `ItemsRepository` для поддержки удаления элементов.&#10;&#10;### Шаг 1: Добавление `DeleteItemProcessor`&#10;&#10;Создадим новый класс `DeleteItemProcessor`, который будет обрабатывать запросы на удаление элементов.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.io.IOException;&#10;import java.io.OutputStream;&#10;&#10;public class DeleteItemProcessor implements RequestProcessor {&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public DeleteItemProcessor(ItemsRepository itemsRepository) {&#10;        this.itemsRepository = itemsRepository;&#10;    }&#10;&#10;    @Override&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        String idParam = request.getParameter(&quot;id&quot;);&#10;        if (idParam == null) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nMissing 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            return;&#10;        }&#10;&#10;        try {&#10;            int id = Integer.parseInt(idParam);&#10;            boolean deleted = itemsRepository.deleteItem(id);&#10;            if (deleted) {&#10;                String response = &quot;HTTP/1.1 200 OK\r\n\r\nItem deleted successfully&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            } else {&#10;                String response = &quot;HTTP/1.1 404 Not Found\r\n\r\nItem not found&quot;;&#10;                out.write(response.getBytes(StandardCharsets.UTF_8));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            String response = &quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid 'id' parameter&quot;;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 2: Регистрация `DeleteItemProcessor` в `Dispatcher`&#10;&#10;Обновим класс `Dispatcher`, чтобы зарегистрировать новый процессор для обработки запросов `DELETE /items`.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Dispatcher {&#10;    private Map&lt;String, RequestProcessor&gt; processors;&#10;    private RequestProcessor defaultNotFoundRequestProcessor;&#10;    private RequestProcessor defaultInternalServerErrorProcessor;&#10;&#10;    private ItemsRepository itemsRepository;&#10;&#10;    public Dispatcher() {&#10;        this.itemsRepository = new ItemsRepository();&#10;&#10;        this.processors = new HashMap&lt;&gt;();&#10;        this.processors.put(&quot;GET /&quot;, new HelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /another&quot;, new AnotherHelloWorldRequestProcessor());&#10;        this.processors.put(&quot;GET /calculator&quot;, new CalculatorRequestProcessor());&#10;        this.processors.put(&quot;GET /items&quot;, new GetAllItemsProcessor(itemsRepository));&#10;        this.processors.put(&quot;POST /items&quot;, new CreateNewItemProcessor(itemsRepository));&#10;        this.processors.put(&quot;DELETE /items&quot;, new DeleteItemProcessor(itemsRepository)); // Регистрация нового процессора&#10;&#10;        this.defaultNotFoundRequestProcessor = new DefaultNotFoundRequestProcessor();&#10;        this.defaultInternalServerErrorProcessor = new DefaultInternalServerErrorRequestProcessor();&#10;    }&#10;&#10;    public void execute(HttpRequest request, OutputStream out) throws IOException {&#10;        try {&#10;            if (!processors.containsKey(request.getRoutingKey())) {&#10;                defaultNotFoundRequestProcessor.execute(request, out);&#10;                return;&#10;            }&#10;            processors.get(request.getRoutingKey()).execute(request, out);&#10;        } catch (BadRequestException e) {&#10;            e.printStackTrace();&#10;            DefaultErrorDto defaultErrorDto = new DefaultErrorDto(&quot;CLIENT_DEFAULT_ERROR&quot;, e.getMessage());&#10;            String jsonError = new Gson().toJson(defaultErrorDto);&#10;            String response = &quot;&quot; +&#10;                    &quot;HTTP/1.1 400 Bad Request\r\n&quot; +&#10;                    &quot;Content-Type: application/json\r\n&quot; +&#10;                    &quot;\r\n&quot; +&#10;                    jsonError;&#10;            out.write(response.getBytes(StandardCharsets.UTF_8));&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            defaultInternalServerErrorProcessor.execute(request, out);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Шаг 3: Обновление `ItemsRepository` для поддержки удаления элементов&#10;&#10;Добавим метод `deleteItem` в `ItemsRepository`.&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class ItemsRepository {&#10;    private Map&lt;Integer, Item&gt; items = new HashMap&lt;&gt;();&#10;    private int currentId = 1;&#10;&#10;    public Item getItem(int id) {&#10;        return items.get(id);&#10;    }&#10;&#10;    public void addItem(Item item) {&#10;        item.setId(currentId++);&#10;        items.put(item.getId(), item);&#10;    }&#10;&#10;    public boolean deleteItem(int id) {&#10;        return items.remove(id) != null;&#10;    }&#10;&#10;    public Map&lt;Integer, Item&gt; getAllItems() {&#10;        return items;&#10;    }&#10;}&#10;```&#10;&#10;### Итог&#10;&#10;Теперь у вас есть возможность удалять продукты через `DELETE /items?id=10`. Мы добавили новый процессор `DeleteItemProcessor`, зарегистрировали его в `Dispatcher` и обновили `ItemsRepository` для поддержки удаления элементов." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1722415340775" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Dispatcher.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/RequestHandler.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/basic/Application.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>